{"version":3,"file":"abstractAudioSubGraph.js","sourceRoot":"","sources":["../../../../../../dev/core/src/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.ts"],"names":[],"mappings":"AAIA;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAgB,sBAAsB;IAA5C;QACY,2BAAsB,GAAsD,EAAE,CAAC;QAC/E,cAAS,GAA8C,EAAE,CAAC;QAyF1D,uBAAkB,GAAG,CAAC,IAAuB,EAAE,EAAE;YACrD,MAAM,OAAO,GAAG,IAA8B,CAAC;YAE/C,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAEpC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC9B,CAAC,CAAC;IACN,CAAC;IA9FG;;;;;;;;OAQG;IACI,aAAa,CAAkC,IAAY,EAAE,QAA2B;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,IAAI,EAAE,CAAC;YACP,QAAQ,CAAC,IAAS,CAAC,CAAC;YACpB,OAAO;QACX,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAErF,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;YAClB,QAAQ,CAAC,IAAS,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACI,OAAO;QACV,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC/C,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC7B,OAAO,CAAC,OAAO,EAAE,CAAC;QACtB,CAAC;QAED,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,sBAAsB,GAAG,EAAE,CAAC;IACrC,CAAC;IAED;;;;;SAKK;IACE,UAAU,CAAmC,IAAY;QAC5D,OAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAO,IAAI,IAAI,CAAC;IAC/C,CAAC;IAID;;;OAGG;IACO,kBAAkB,KAAU,CAAC;IAE7B,8BAA8B;QACpC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;IACnE,CAAC;IAEO,WAAW,CAAC,IAA4B;QAC5C,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;QAEjC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAE1D,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC9B,CAAC;IAES,oBAAoB,CAAC,IAAY;QACvC,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAE1C,IAAI,CAAC,OAAO,EAAE,CAAC;YACX,OAAO,OAAO,CAAC,MAAM,CAAC,6BAA6B,IAAI,GAAG,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAChE,OAAO;iBACF,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;gBACX,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBACvB,OAAO,CAAC,IAAI,CAAC,CAAC;YAClB,CAAC,CAAC;iBACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACb,MAAM,CAAC,KAAK,CAAC,CAAC;YAClB,CAAC,CAAC,CAAC;QACX,CAAC,CAAC,CAAC;QAEH,OAAO,OAAO,CAAC;IACnB,CAAC;CASJ","sourcesContent":["import type { Nullable } from \"../../../types\";\nimport type { AbstractAudioNode, AbstractNamedAudioNode } from \"../abstractAudioNode\";\nimport type { _AbstractAudioSubNode } from \"./abstractAudioSubNode\";\n\n/**\n * Adds common sub graph functionality to an audio node.\n *\n * Audio nodes such as static sounds, streaming sounds, and buses can use audio sub graphs to process audio internally\n * before sending it to connected downstream audio nodes. This is useful for applying effects, spatial audio, and other\n * audio processing tasks common to multiple audio node classes.\n *\n * A key feature of audio sub graphs is their audio sub nodes are created asynchronously on demand so the minimum set\n * of sub nodes are used at all times to save memory and CPU resources. The tradeoff is a small delay when first\n * setting a property backed by a sub node. This delay is avoided by using the appropriate options to initialize the\n * sub node on creation, e.g. `spatialEnabled` and `stereoEnabled`, or by setting any creation option backed by the\n * sub node, e.g. `spatialPosition` and `stereoPan`.\n *\n * @internal\n */\nexport abstract class _AbstractAudioSubGraph {\n    private _createSubNodePromises: { [key: string]: Promise<_AbstractAudioSubNode> } = {};\n    private _subNodes: { [key: string]: AbstractNamedAudioNode } = {};\n\n    /**\n     * Executes the given callback with the named sub node, creating the sub node if needed.\n     *\n     * Note that `callback` is executed synchronously if the sub node already exists, otherwise the sub node is created\n     * asynchronously before `callback` is executed.\n     *\n     * @param name The name of the sub node\n     * @param callback The function to call with the named sub node\n     */\n    public callOnSubNode<T extends _AbstractAudioSubNode>(name: string, callback: (node: T) => void): void {\n        const node = this.getSubNode(name);\n        if (node) {\n            callback(node as T);\n            return;\n        }\n\n        const promise = this._createSubNodePromises[name] ?? this._createAndAddSubNode(name);\n\n        promise.then((node) => {\n            callback(node as T);\n        });\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public dispose() {\n        const subNodes = Object.values(this._subNodes);\n        for (const subNode of subNodes) {\n            subNode.dispose();\n        }\n\n        this._subNodes = {};\n        this._createSubNodePromises = {};\n    }\n\n    /**\n     * Gets a previously created sub node.\n     * @param name - The name of the sub node\n     * @returns The named sub node, or `null` if it has not been created, yet\n     * @internal\n     * */\n    public getSubNode<T extends AbstractNamedAudioNode>(name: string): Nullable<T> {\n        return (this._subNodes[name] as T) ?? null;\n    }\n\n    protected abstract _createSubNode(name: string): Nullable<Promise<_AbstractAudioSubNode>>;\n\n    /**\n     * Called when sub-nodes are added or removed.\n     * - Override this to connect and reconnect sub-nodes as needed.\n     */\n    protected _onSubNodesChanged(): void {}\n\n    protected _createSubNodePromisesResolved(): Promise<_AbstractAudioSubNode[]> {\n        return Promise.all(Object.values(this._createSubNodePromises));\n    }\n\n    private _addSubNode(node: AbstractNamedAudioNode): void {\n        this._subNodes[node.name] = node;\n\n        node.onDisposeObservable.addOnce(this._onSubNodeDisposed);\n\n        this._onSubNodesChanged();\n    }\n\n    protected _createAndAddSubNode(name: string): Promise<_AbstractAudioSubNode> {\n        const promise = this._createSubNode(name);\n\n        if (!promise) {\n            return Promise.reject(`Failed to create subnode \"${name}\"`);\n        }\n\n        this._createSubNodePromises[name] = new Promise((resolve, reject) => {\n            promise\n                .then((node) => {\n                    this._addSubNode(node);\n                    resolve(node);\n                })\n                .catch((error) => {\n                    reject(error);\n                });\n        });\n\n        return promise;\n    }\n\n    private _onSubNodeDisposed = (node: AbstractAudioNode) => {\n        const subNode = node as AbstractNamedAudioNode;\n\n        delete this._subNodes[subNode.name];\n\n        this._onSubNodesChanged();\n    };\n}\n"]}