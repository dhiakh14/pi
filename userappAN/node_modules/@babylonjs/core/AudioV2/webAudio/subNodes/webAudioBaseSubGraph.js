import { _AbstractAudioSubGraph } from "../../abstractAudio/subNodes/abstractAudioSubGraph.js";
import { _GetVolumeAudioSubNode } from "../../abstractAudio/subNodes/volumeAudioSubNode.js";
import { _CreateVolumeAudioSubNodeAsync } from "./volumeWebAudioSubNode.js";
/** @internal */
export class _WebAudioBaseSubGraph extends _AbstractAudioSubGraph {
    /** @internal */
    constructor(owner) {
        super();
        this._outNode = null;
        this._owner = owner;
    }
    /** @internal */
    async init(options) {
        this._createAndAddSubNode("Volume" /* AudioSubNode.VOLUME */);
        await this._createSubNodePromisesResolved();
        const volumeNode = _GetVolumeAudioSubNode(this);
        if (!volumeNode) {
            throw new Error("No volume subnode.");
        }
        volumeNode.setOptions(options);
        if (volumeNode.getClassName() !== "_VolumeWebAudioSubNode") {
            throw new Error("Not a WebAudio subnode.");
        }
        this._outNode = volumeNode.node;
        // Connect the new wrapped WebAudio node to the wrapped downstream WebAudio nodes.
        // The wrapper nodes are unaware of this change.
        if (this._outNode && this._downstreamNodes) {
            const it = this._downstreamNodes.values();
            for (let next = it.next(); !next.done; next = it.next()) {
                const inNode = next.value.inNode;
                if (inNode) {
                    this._outNode.connect(inNode);
                }
            }
        }
    }
    /** @internal */
    get inNode() {
        return this._outNode;
    }
    /** @internal */
    get outNode() {
        return this._outNode;
    }
    _createSubNode(name) {
        switch (name) {
            case "Volume" /* AudioSubNode.VOLUME */:
                return _CreateVolumeAudioSubNodeAsync(this._owner.engine);
            default:
                return null;
        }
    }
}
//# sourceMappingURL=webAudioBaseSubGraph.js.map