{"version":3,"file":"flowGraphJsonPointerParserBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { FlowGraphBlock } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { FlowGraphPathConverterComponent } from \"core/FlowGraph/flowGraphPathConverterComponent\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport type { IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport type { Animation } from \"core/Animations/animation\";\nimport type { EasingFunction } from \"core/Animations/easing\";\nimport type { Vector4 } from \"core/Maths/math.vector\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\n\n/**\n * Configuration for the JSON pointer parser block.\n */\nexport interface IFlowGraphJsonPointerParserBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The JSON pointer to parse.\n     */\n    jsonPointer: string;\n    /**\n     * The path converter to use to convert the path to an object accessor.\n     */\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\n\n    /**\n     * Whether to output the value of the property.\n     */\n    outputValue?: boolean;\n}\n\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphBlock {\n    /**\n     * Output connection: The object that contains the property.\n     */\n    public readonly object: FlowGraphDataConnection<O>;\n\n    /**\n     * Output connection: The property name.\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Output connection: The value of the property.\n     * Note that per default this is not outputted. It can be enabled by setting the outputValue property to true.\n     */\n    public readonly value: FlowGraphDataConnection<P>;\n\n    /**\n     * Output connection: A function that can be used to update the value of the property.\n     */\n    public readonly setterFunction: FlowGraphDataConnection<(target: O, propertyName: string, value: P, context: FlowGraphContext) => void>;\n\n    /**\n     * Output connection: A function that can be used to get the value of the property.\n     */\n    public readonly getterFunction: FlowGraphDataConnection<(target: O, propertyName: string, context: FlowGraphContext) => P | undefined>;\n\n    /**\n     * Output connection: A function that can be used to get the interpolation animation property info.\n     */\n    public readonly generateAnimationsFunction: FlowGraphDataConnection<() => (keys: any[], fps: number, easingFunction?: EasingFunction) => Animation[]>;\n\n    /**\n     * Output connection: Whether the value is valid.\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    /**\n     * The component with the templated inputs for the provided path.\n     */\n    public readonly templateComponent: FlowGraphPathConverterComponent;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphJsonPointerParserBlockConfiguration\n    ) {\n        super(config);\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeAny);\n        if (config.outputValue) {\n            this.value = this.registerDataOutput(\"value\", RichTypeAny);\n        }\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext) {\n        try {\n            const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n            const value = accessorContainer.info.get(accessorContainer.object);\n            const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n            const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n            if (!object) {\n                this.isValid.setValue(false, context);\n                return;\n            } else {\n                this.object.setValue(object, context);\n                if (propertyName) {\n                    this.propertyName.setValue(propertyName, context);\n                }\n                this.isValid.setValue(true, context);\n            }\n            if (this.config.outputValue) {\n                if (value === undefined) {\n                    this.isValid.setValue(false, context);\n                } else {\n                    this.value.setValue(value, context);\n                    this.isValid.setValue(true, context);\n                }\n            }\n        } catch (e) {\n            this.isValid.setValue(false, context);\n            return;\n        }\n    }\n\n    private _setPropertyValue(_target: O, _propertyName: string, value: P, context: FlowGraphContext): void {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value as Vector4, type) as unknown as P;\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n\n    private _getPropertyValue(_target: O, _propertyName: string, context: FlowGraphContext): P | undefined {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return accessorContainer.info.get(accessorContainer.object);\n    }\n\n    private _getInterpolationAnimationPropertyInfo(\n        _target: O,\n        _propertyName: string,\n        context: FlowGraphContext\n    ): (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => Animation[] {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => {\n            const animations: Animation[] = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys: any[] = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                animationData.forEach((animation) => {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                });\n            });\n\n            return animations;\n        };\n    }\n\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.JsonPointerParser;\n    }\n}\n\nfunction ToColor(value: any, expectedValue: string) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value as unknown as Color3 | Color4;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    } else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\n\nRegisterClass(FlowGraphBlockNames.JsonPointerParser, FlowGraphJsonPointerParserBlock);\n"]}